# require-extension

This aims to solve a problem within node.js.
If you look at node documentation you will see that it has been deprecated which mean that we shouldn't use it anymore. However the module is locked so it will be around and never changed.

This feature allowed you to do many things with node such as compiling JavaScript on the fly. Transpilers such as babel depends on this feature when using modules such as babel-node.

The issue is that this is a global function and different module competing would overwrite each other.

If you want something to strip comments, while loading JavaScript from es6 this would be impossible to do. The solutions for node is to compile the file previously using a build system.

This makes sense interns of production and published module, however for development this is pretty needed feature. Especially with so many compilers and features that are available.

        require.extensions[".js"] = function(module,filename){
          //compile file          
        }

This now has been changed to

        require.extensions[".js"] = function(content,filename){
          return transpile_function(content)
        }

The content is the recently transformed file.
This opens the door to do many things on load.
You can add as many functions to require.extensions as you want. It will just chain the compilation.


For example

      require.extensions[".js"] = function(content,filename){
        return strip_comments(content);
      }

      require.extensions[".js"] = function(content,filename){
        return babel.transform(content,options).code;
      }

      require.extensions[".js"] = function(content,filename){
        return some_other_useful_compilation(content)
      }



This chaining of events would allow you to do things like remove logs. Which would be a simple use case but you can do other things such as remove comments only from certain files.

Then you can pass this to babel.transform which will compile the es6 module. This would then move on to do some_other_useful_compilation which could maybe check for syntax error, or caching or anything else.



Imagine being able to cache your compilations, transform, check for code quality and run the program all from one place without having to transpile it.


## API

This module was written with es6, so you can import or require certain features.

### Alarm

      import {Alarm} from "require-extensions";
      //or
      var Alarm = require("require-extensions").Alarm

#### Events

##### Warning
The warning event will trigger a message whenever a transform function did not compile and return a string.


#### Register
  This will expand the module to cover additional extensions. By default .js is registered

#### Extended function
      var register = require("require-extensions")
      register(".es6")
      //this will allow you to stack the amount of transform you do on the extension .es6

      require.extensions = function(/*String*/ code,/*String*/ filename){
        //compile code and return it

        compile_function(code);
      }

The filename is passed as well so that it can be used to do things if you know the filename, Better Error messages, inserting information at transpile time and so on.

#### _Notes_

All compilation must be SYNC. Node Loads every JavaScript file Synchronously so that it can be imported right away.


By default this ignores all node_modules and there are no plans to change it as of yet. This is to encourage transpiled modules only in the npm repository. I would hate to give people an excuse to do all of these things at runtime.

This is mean to ease development not used in production.


If you would like create a module we would like the follow the same direction of so many other loading system


        var your_module = require("your_module_name");

        //this would register your module to use which ever extension of choice.
        your_module(options)

        //Remember that only js extensions work by default.

        //Re-registering and module doesn't cause any issues, just register it if you need it.

        //example


        //index.js
        var babel = require("babel-code")

        module.exports = function(options){
          return function(code,filename){
            return babel.transform(code,options).code
          }
        }

        //register.js
        var babel_registration = require("./index.js")
        //load config from package.json / .babelrc or where ever

        require.extensions[".js"] = babel_registration(options)


This would be all the code you would need to allow a user to load babel at runtime. Please note certain features such as files to be ignored/include would need to be programmed. If you don't want to add any transformation to the code and just want to log some data you can return the code string. If it is not returned of it's not a string Alarm will trigger a "warning" event and ignore the transformation.



Extensions will follow a simple naming convention of <name>-extension


## How to Load extensions

Extensions can be loaded using the .extensions file. How this works is the require-extension will load the file and pass the content and the file name to the extension file.

Extensions can be added to the require.extension[".extension-name"] object.

      require.extensions[".js"]= function(sourcecode,filename){
        sourcecode += "//Ending of "+filename

        //This will add the following comment to all loaded files.
        //Ofcourse it can do much more interesting things with the source

        return sourcecode;
      }


Inorder to pass certain options to the extension that a user might want to configure use a registration method
              //Module CommentStrip/register.js
              function RegisterMyCommentTranspiler(options){

                require.extension[".js"]= function(sourcecode,filename){
                  if(!options.showComments){
                      //strip all comments
                  }
                  return sourcecode
                }
              }


A user can then incorporate this be creating the .extensions file.


      {
        extensions:[{
          name:"CommentString/register.js",
          options:{
            showComments:true
          }
        }]

      }
