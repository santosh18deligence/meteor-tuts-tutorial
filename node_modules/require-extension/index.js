"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Alarm = undefined;
exports.get_loaders = get_loaders;
exports.set_loaders = set_loaders;
exports.extensionOf = extensionOf;
exports._register = _register;

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _module = require("module");

var _module2 = _interopRequireDefault(_module);

var _stripBom = require("strip-bom");

var _stripBom2 = _interopRequireDefault(_stripBom);

var _os = require("os");

var _os2 = _interopRequireDefault(_os);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _events = require("events");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = require("debug")("node.debug.register");

//TODO prove that i expect a function that can absorb other functions

/****************************************

  Read File and Caches the result.
  When the same file is read again it
  will just return the output.

  This might not be needed.
  Node does it's own caching

****************************************/
//Imports
var readfile = _lodash2.default.memoize(_fs2.default.readFileSync);

/*********************************

This will be the storage area for
all the functions that will provide
a transform on the source code

**********************************/
const store = [];

class RegisterEmitter extends _events2.default {
  constructor() {
    super();
  }
}

//Might not really be needed.
var Alarm = exports.Alarm = new RegisterEmitter();

var ready = false;
var IsReady = function (filename) {
  if (filename === process.argv[1]) {
    ready = true;
  }

  return ready;
};

function get_loaders() {

  let loader = function (module, filename) {

    /************************************************
        This is the new loading of code.
      This replaces nodes version
      *************************************************/
    if (!_lodash2.default.isObject(module) || !_lodash2.default.isString(filename)) {

      //Exit If Objects are not correct
      throw new Error(`module or filename is not correct for custom extensions\nmodule ${ typeof module }\nfilename ${ typeof filename }`);
    }

    let source_code = readfile(filename, 'utf8');

    if (/node_modules/.test(filename)) {
      return source_code;
    }

    //Waits for main module to load before compiling
    if (!IsReady(filename)) {
      return source_code;
    }

    //Not sure why needed
    source_code = (0, _stripBom2.default)(source_code);

    //Begin Compilation
    for (var func of store) {

      var temp = func(source_code, filename);
      if (!_lodash2.default.isString(temp)) {
        var index = store.indexOf(func);
        Alarm.emit("warning", {
          message: "function skipped. All functions should return a string representation of the current src being compiled",
          callback: func,
          filename,
          index
        });
      } else {
        source_code = temp;
      }
    }

    return source_code;
  };

  //Another Level Of Caching Might not be needed
  loader = _lodash2.default.memoize(loader, function (module, filename) {
    return filename;
  });

  //This will be the getter for loading functions
  return function (module, filename) {
    if (!_lodash2.default.isObject(module) || !_lodash2.default.isString(filename)) {
      throw new Error(`module or filename is not correct\nmodule ${ typeof module }\nfilename ${ typeof filename }`);
    }
    var content = loader(module, filename);

    if (!_lodash2.default.isString(content)) {
      throw new Error("Content is not a string");
    }
    module._compile(content, filename);
  };
}

//This will be the setter for loading functions
function set_loaders(_new_transpiler) {
  store.push(_new_transpiler);
}

function extensionOf(extension) {
  try {
    Object.defineProperty(require.extensions, extension, {
      configurable: false,
      enumerable: true,
      get: get_loaders,
      set: set_loaders
    });
  } catch (e) {}
}

function _register(extension) {
  extensionOf(extension);
}

//Another Level of Cache
//No need to load extension twice
var register = _lodash2.default.memoize(_register);

register(".js");

Alarm.on("warning", function () {
  log(arguments);
});

exports.default = register;